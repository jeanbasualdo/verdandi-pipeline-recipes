name: .NET API Service CI-CD

on:
  workflow_call:
    inputs:
      internal_name:
        required: true
        type: string
      infrastructure_secret_name:
        required: true
        type: string
      bucket_for_schemas:
        required: true
        type: string
      terraform_folder:
        required: true
        type: string
      version_file:
        required: false
        type: string
        default: .version
      dotnet_test_command:
        required: false
        type: string
        default: dotnet test --logger trx /p:CollectCoverage=true /p:CoverletOutputFormat=opencover /p:Threshold=70
      nuget_template_path:
        required: false
        type: string
        default: .nuget.config
      openapi_schema:
        required: false
        type: string
        default: main.openapi.yaml
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Set up .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: 5.0.200
      - name: Load Cluster Configuration
        uses: say8425/aws-secrets-manager-actions@v2
        with:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          SECRET_NAME: ${{ inputs.infrastructure_secret_name }}
      - name: Load Instance Configuration
        uses: say8425/aws-secrets-manager-actions@v2
        with:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          SECRET_NAME: ${{ inputs.internal_name }}@${{ github.ref }}
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - uses: addnab/docker-run-action@v3
        name: App - Check Secrets in Repository
        with:
          registry: gcr.io
          image: zricethezav/gitleaks:latest
          options: -v ${{ github.workspace }}:/path
          run: |
            gitleaks detect -v -s /path  --no-git
      - name: App - Scan Dependencies for Security Issues
        run: |
          envsubst < "${{ inputs.nuget_template_path }}" > "nuget.config"
          dotnet restore
          dotnet list package --vulnerable --include-transitive
        env:
          OWNER: ${{ env.GITHUB_OWNER }}
          TOKEN: ${{ env.GITHUB_TOKEN }}
      - name: Set up JDK 11
        uses: actions/setup-java@v1
        with:
          java-version: 1.11
      - name: Cache SonarQube packages
        uses: actions/cache@v1
        with:
          path: ~/sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
      - name: Cache SonarQube scanner
        id: cache-sonar-scanner
        uses: actions/cache@v1
        with:
          path: ./.sonar/scanner
          key: ${{ runner.os }}-sonar-scanner
          restore-keys: ${{ runner.os }}-sonar-scanner
      - name: Install SonarQube scanner
        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
        run: |
          mkdir ./.sonar
          mkdir ./.sonar/scanner
          dotnet tool update dotnet-sonarscanner --tool-path ./.sonar/scanner
      - name: App - Build, Test and Coverage
        run: |
          envsubst < "${{ inputs.nuget_template_path }}" > "nuget.config"
          dotnet restore

          ./.sonar/scanner/dotnet-sonarscanner begin /k:"${{ env.SONAR_ID }}" /d:sonar.cs.opencover.reportsPaths="**/*.opencover.xml" /d:sonar.login="${{ env.SONAR_TOKEN }}" /d:sonar.host.url="${{ env.SONAR_HOST_URL }}" /d:sonar.cs.vstest.reportsPaths="**/*.trx"
          dotnet build --configuration Release
          eval "${{ inputs.dotnet_test_command }}"
          ./.sonar/scanner/dotnet-sonarscanner end /d:sonar.login="${{ env.SONAR_TOKEN }}"
        env:
          OWNER: ${{ env.GITHUB_OWNER }}
          TOKEN: ${{ env.GITHUB_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_PROFILE: default
          ACTIONS_ALLOW_UNSECURE_COMMANDS: true
  package:
    runs-on: ubuntu-latest
    needs: ci
    steps:
      - name: Load Cluster Configuration
        uses: say8425/aws-secrets-manager-actions@v2
        with:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          SECRET_NAME: ${{ inputs.infrastructure_secret_name }}
      - name: Load Instance Configuration
        uses: say8425/aws-secrets-manager-actions@v2
        with:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          SECRET_NAME: ${{ inputs.internal_name }}@${{ github.ref }}
      - uses: actions/checkout@v2
      - name: App - Load Version Number
        run: |
          echo "APP_VERSION=$(cat ${{ inputs.version_file }})" >> $GITHUB_ENV
      - name: App - Update REST Schemas
        run: |
          aws s3 cp ${{ inputs.openapi_schema }} s3://${{ inputs.bucket_for_schemas }}/schemas/${{ inputs.internal_name }}/${{ env.ENVIRONMENT }}/main.openapi.yaml --acl public-read
          aws s3 cp ${{ inputs.openapi_schema }} s3://${{ inputs.bucket_for_schemas }}/schemas/${{ inputs.internal_name }}/${{ env.ENVIRONMENT }}/${{ env.APP_VERSION }}/main.openapi.yaml --acl public-read
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      - name: App - Build Image
        run: |
          envsubst < "${{ inputs.nuget_template_path }}" > "nuget.config"
          docker build --tag "${{ env.IMAGE_SHORT_NAME }}:$APP_VERSION" .
        env:
          OWNER: ${{ env.GITHUB_OWNER }}
          TOKEN: ${{ env.GITHUB_TOKEN }}
      - name: App - Push to ECR
        id: ecr
        uses: jwalton/gh-ecr-push@v1
        with:
          access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          region: us-east-1
          image: "${{ env.IMAGE_SHORT_NAME }}:${{ env.APP_VERSION }}"
  deploy:
    runs-on: ubuntu-latest
    needs: package
    steps:
      - name: Load Cluster Configuration
        uses: say8425/aws-secrets-manager-actions@v2
        with:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          SECRET_NAME: ${{ inputs.infrastructure_secret_name }}
      - name: Load Instance Configuration
        uses: say8425/aws-secrets-manager-actions@v2
        with:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          SECRET_NAME: ${{ inputs.internal_name }}@${{ github.ref }}
      - uses: actions/checkout@v2
      - name: App - Terraforming
        run: |
          echo "APP_VERSION=$(cat ${{ inputs.version_file }})" >> $GITHUB_ENV
          cd ${{ inputs.terraform_folder }}
          eval `ssh-agent -s`
          ssh-add - <<< '${{ env.GITHUB_SSH_KEY }}'
          export TF_VAR_app_name=${{ inputs.internal_name }}
          export TF_VAR_app_version=${{ env.APP_VERSION }}
          export TF_VAR_environment=${{ env.ENVIRONMENT }}
          export TF_VAR_app_secret_name="${{ inputs.internal_name }}@${{ github.ref }}"
          terraform init -backend-config="bucket=${{ env.TERRAFORM_BUCKET }}" -backend-config="key=${{ inputs.internal_name }}/${{ env.ENVIRONMENT }}/terraform.tfstate"
          # terraform apply -auto-approve -input=false
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          AWS_SDK_LOAD_CONFIG: true
          ACTIONS_ALLOW_UNSECURE_COMMANDS: true
